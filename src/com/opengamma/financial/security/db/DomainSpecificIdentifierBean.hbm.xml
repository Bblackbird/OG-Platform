<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.opengamma.financial.security.db">
  <class name="DomainSpecificIdentifierAssociationBean" table="domain_specific_identifier_association">
    <id name="id">
      <generator class="org.hibernate.id.enhanced.SequenceStyleGenerator"/>
    </id>
    <property name="validStartDate" type="date" not-null="false" />
    <property name="validEndDate" type="date" not-null="false" />
    <!-- this is a special association that deals with the fact we've implemented
         securities with a table-per-concrete class model.  This means that whenever
         we have a polymorphic reference to the base class we need a discriminator to
         tell us which table to look in.  We use table-per-concrete class because in 
         the normal lookup case it means we can avoid joins. -->
    <any name="security"
         meta-type="string"
         id-type="long"
         cascade="save-update">
      <meta-value value="EQUITY" class="EquitySecurityBean"/>
      <!--  insert more subclasses of SecurityBean here -->
      <!--  note the order is important here -->
      <column name="security_discriminator"/>
      <column name="security_id"/>
    </any>
    <!-- component means that it's 'part of' the object, although Java models it as a reference, I wanted
         the actual identifier to be a separate class -->
    <component name="domainSpecificIdentifier"
               class="DomainSpecificIdentifierBean">
      <property name="domain" type="string" not-null="true" unique-key="unique_associations"/>
      <property name="identifier" type="string" not-null="true" unique-key="unique_associations"/>
    </component>
  </class>
  <!-- queries on this entity -->
  <query name="SecurityBean.one.byDateDomainIdentifier">
    select 
      s
    from 
      DomainSpecificIdentifierAssociationBean as a,
      SecurityBean as s
    where
      a.security = s.firstVersion and
      ((a.validStartDate is null) or (a.validStartDate &lt;= :now) and
       (a.validEndDate is null) or (a.validEndDate &gt; :now)) and
      a.domainSpecificIdentifier.domain = :domain and
      a.domainSpecificIdentifier.identifier = :identifier and
      s.effectiveDateTime &lt;= :now and
      not exists (select 
                    latest.id
                  from 
                    SecurityBean as latest
                  where
                    latest.effectiveDateTime &lt; :now and
                    latest.effectiveDateTime &gt; s.effectiveDateTime and
                    latest.id &lt;&gt; s.id)
  </query>
  <!-- note the s, and the 'in (:identifiers)' part of the where -->
  <query name="SecurityBean.one.byDateDomainIdentifiers"> 
    select 
      s
    from 
      DomainSpecificIdentifierAssociationBean as a,
      SecurityBean as s
    where
      a.security = s.firstVersion and
      ((a.validStartDate is null) or (a.validStartDate &lt;= :now) and
       (a.validEndDate is null) or (a.validEndDate &gt; :now)) and
      a.domainSpecificIdentifier.domain = :domain and
      a.domainSpecificIdentifier.identifier in (:identifiers) and
      s.effectiveDateTime &lt; :now and
      not exists (select 
                    latest.id
                  from 
                    SecurityBean as latest
                  where
                    latest.effectiveDateTime &lt; :now and
                    latest.effectiveDateTime &gt; s.effectiveDateTime and
                    latest.id &lt;&gt; s.id)
  </query>
  <query name="DomainSpecificIdentifierAssociationBean.one.byDateDomainIdentifier">
    from 
      DomainSpecificIdentifierAssociationBean as a 
    where
      ((a.validStartDate is null) or (a.validStartDate &lt;= :now) and
       (a.validEndDate is null) or (a.validEndDate &gt; :now)) and
      a.domainSpecificIdentifier.domain = :domain and
      a.domainSpecificIdentifier.identifier = :identifier
  </query>
  <query name="DomainSpecificIdentifierAssociationBean.one.byDateDomainIdentifierSecurity">
    from 
      DomainSpecificIdentifierAssociationBean as a 
    where
      ((a.validStartDate is null) or (a.validStartDate &lt;= :now) and
       (a.validEndDate is null) or (a.validEndDate &gt; :now)) and
      a.domainSpecificIdentifier.domain = :domain and
      a.domainSpecificIdentifier.identifier = :identifier and
      a.security = :security
  </query>
  <query name="DomainSpecificIdentifierAssociationBean.many.byDateSecurity">
    from 
      DomainSpecificIdentifierAssociationBean as a 
    where
      ((a.validStartDate is null) or (a.validStartDate &lt;= :now) and
       (a.validEndDate is null) or (a.validEndDate &gt; :now)) and
      a.security = :security
  </query>
  <query name="DomainSpecificIdentifierAssociationBean.one.previousAssociation">
    from
      DomainSpecificIdentifierAssociationBean as a
    where
      a.domain = :domain and
      a.security = :security and
      a.validEndDate = (select max(b.validEndDate) from DomainSpecificIdentifierBean as b where b.domain = :domain and b.identifier = :identifier and b.validEndDate &lt;= now)
  </query>
  <query name="DomainSpecificIdentifierAssociationBean.one.nextAssociation">
    from
      DomainSpecificIdentifierAssociationBean as a
    where
      a.domain = :domain and 
      a.security = :security and 
      a.validStartDate = (select mind(b.validStartDate) from DomainSpecificIdentifierBean as b where b.domain = :domain and b.identifier = :identifier as b.validStartDate &gt; now)
  </query>
</hibernate-mapping>