/**
 * Copyright (C) 2009 - 2010 by OpenGamma Inc.
 *
 * Please see distribution for license.
 */
package com.opengamma.financial;

import java.util.Collection;
import java.util.Collections;

import javax.time.calendar.LocalDate;

import com.opengamma.OpenGammaRuntimeException;
import com.opengamma.id.Identifier;
import com.opengamma.id.IdentifierBundle;
import com.opengamma.id.IdentifierBundleMapper;
import com.opengamma.id.UniqueIdentifier;
/**
 * In-memory implementation of HolidayRepository that is populated from CSV files.
 * THIS IMPLEMENTAION DOES NOT IMPLEMENT VERSIONING, DATES PASSED IN ARE IGNORED
 */
public class InMemoryHolidayRepository implements HolidayRepository {
  // TODO: jim 2-Jul-2010 -- Make this cope with versioning...
  /**
   * Scheme used for UniqueIdentfiers generated by this class
   */
  public static final String HOLIDAY_SCHEME = "HOLIDAY_SCHEME";
  private static final String HOLIDAY_CURRENCY_SCHEME = "HOLIDAY_CURRENCY_SCHEME";
  
  private IdentifierBundleMapper<Holiday> _idMapper = new IdentifierBundleMapper<Holiday>(HOLIDAY_SCHEME);
  private RegionRepository _regionRepo;
  private ExchangeRepository _exchangeRepo;

  public InMemoryHolidayRepository(RegionRepository regionRepo, ExchangeRepository exchangeRepo) {
    _regionRepo = regionRepo;
    _exchangeRepo = exchangeRepo;
  }

  @Override
  public synchronized UniqueIdentifier addHoliday(Currency currency, Collection<LocalDate> holidayDates) {
    Holiday holiday = new Holiday(currency, holidayDates);
    UniqueIdentifier uniqueIdentifier = _idMapper.add(IdentifierBundle.of(Identifier.of(HOLIDAY_CURRENCY_SCHEME, currency.getISOCode())), holiday);
    holiday.setUniqueIdentifier(uniqueIdentifier);
    return uniqueIdentifier;
  }

  @Override
  public synchronized UniqueIdentifier addHoliday(Identifier exchangeOrRegionId, HolidayType holidayType, Collection<LocalDate> holidayDates) {
    Holiday holiday = new Holiday(exchangeOrRegionId, holidayType, holidayDates);
    UniqueIdentifier uniqueIdentifier = _idMapper.add(IdentifierBundle.of(exchangeOrRegionId), holiday);
    holiday.setUniqueIdentifier(uniqueIdentifier);
    return uniqueIdentifier;   
  }

  @Override
  public HolidayDocument getHoliday(UniqueIdentifier uniqueId) {
    return new HolidayDocument(_idMapper.get(uniqueId));
  }

  @Override
  public HolidaySearchResult searchHistoricHolidays(HolidaySearchHistoricRequest searchHistoricRequest) {
    Identifier identifier;
    Collection<Holiday> holidays;
    switch (searchHistoricRequest.getHolidayType()) {
      case CURRENCY:
        identifier = Identifier.of(HOLIDAY_CURRENCY_SCHEME, searchHistoricRequest.getCurrency().getISOCode());
        holidays = _idMapper.get(identifier);
        break;
      case BANK:
        identifier = searchHistoricRequest.getRegionId();
        RegionSearchResult regionResult = _regionRepo.searchRegions(new RegionSearchRequest(RegionRepository.POLITICAL_HIERARCHY_NAME, identifier));
        IdentifierBundle allIdentifiersForRegion = regionResult.getBestResult().getIdentifiers();
        holidays = _idMapper.get(allIdentifiersForRegion);
        break;
      case SETTLEMENT:
      case TRADING:
        identifier = searchHistoricRequest.getExchangeId();
        ExchangeSearchResult result = _exchangeRepo.searchExchange(new ExchangeSearchRequest(identifier));
        IdentifierBundle allIdentifiersForExchange = result.getSingleExchange().getIdentifiers();
        holidays = _idMapper.get(allIdentifiersForExchange);
        break;
      default:
        throw new OpenGammaRuntimeException("Unsupported holiday type");
    }
    return processResults(searchHistoricRequest, holidays, searchHistoricRequest.getHolidayType());
  }
    
  public HolidaySearchResult processResults(HolidaySearchHistoricRequest searchHistoricRequest, Collection<Holiday> holidays, HolidayType holidayType) {
    for (Holiday holiday : holidays) {
      if (holiday.getHolidayType().equals(holidayType)) {
        if (searchHistoricRequest.getHolidayDate() == null) {
          return singletonSearchResult(holiday);
        } else {
          boolean isCurrencyHoliday = holiday.getHolidays().contains(searchHistoricRequest.getHolidayDate());
          return booleanSearchResult(searchHistoricRequest.getHolidayDate(), isCurrencyHoliday); 
        }          
      }
    }
    // there wasn't a match, so return an appropriate empty/failed search result.
    if (searchHistoricRequest.getHolidayDate() == null) {
      return new HolidaySearchResult(Collections.<HolidayDocument>emptyList());
    } else {
      return new HolidaySearchResult(null, false);
    }
  }

  @Override
  public HolidaySearchResult searchHolidays(HolidaySearchRequest searchRequest) {
    Identifier identifier;
    switch (searchRequest.getHolidayType()) {
      case CURRENCY:
        identifier = Identifier.of(HOLIDAY_CURRENCY_SCHEME, searchRequest.getCurrency().getISOCode());
        break;
      case BANK:
        identifier = searchRequest.getRegionId();
        break;
      case SETTLEMENT:
      case TRADING:
        identifier = searchRequest.getExchangeId();
        break;
      default:
        throw new OpenGammaRuntimeException("Unsupported holiday type");
    }
    Collection<Holiday> holidays = _idMapper.get(identifier);
    return processResults(searchRequest, holidays, searchRequest.getHolidayType());
  }
  
  public HolidaySearchResult processResults(HolidaySearchRequest searchRequest, Collection<Holiday> holidays, HolidayType holidayType) {
    for (Holiday holiday : holidays) {
      if (holiday.getHolidayType().equals(holidayType)) {
        if (searchRequest.getHolidayDate() == null) {
          return singletonSearchResult(holiday);
        } else {
          boolean isCurrencyHoliday = holiday.getHolidays().contains(searchRequest.getHolidayDate());
          return booleanSearchResult(searchRequest.getHolidayDate(), isCurrencyHoliday); 
        }          
      }
    }
    // there wasn't a match, so return an appropriate empty/failed search result.
    if (searchRequest.getHolidayDate() == null) {
      return new HolidaySearchResult(Collections.<HolidayDocument>emptyList());
    } else {
      return new HolidaySearchResult(null, false);
    }
  }
  
  private HolidaySearchResult booleanSearchResult(LocalDate date, boolean result) {
    return new HolidaySearchResult(date, result); 
  }
  
  private HolidaySearchResult singletonSearchResult(Holiday result) {
    if (result != null) {
      HolidayDocument holidayDoc = new HolidayDocument(result);
      return new HolidaySearchResult(Collections.singleton(holidayDoc));
    } else {
      return null;
    }
  }

  @Override
  public HolidayDocument updateHoliday(HolidayDocument holidayDocument) {
    // no-op in memory.
    return holidayDocument;
  }

}
