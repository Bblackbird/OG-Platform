/**
 * Copyright (C) 2009 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.financial.currency;

import com.opengamma.engine.ComputationTarget;
import com.opengamma.engine.function.AbstractFunction;
import com.opengamma.engine.function.FunctionCompilationContext;
import com.opengamma.engine.target.ComputationTargetType;
import com.opengamma.engine.value.ValueProperties;
import com.opengamma.financial.OpenGammaCompilationContext;
import com.opengamma.id.VersionCorrection;
import com.opengamma.timeseries.DoubleTimeSeries;

/**
 * Injects a value from a {@link CurrencyMatrix} into a dependency graph to satisfy the currency requirements generated by {@link CurrencyConversionFunction}.
 */
public abstract class AbstractCurrencyMatrixSourcingFunction extends AbstractFunction.NonCompiledInvoker {
  private static final String CURRENCY_MATRIX_NAME_PROPERTY = "CurrencyMatrix";

  private final String _currencyMatrixName;
  private final String[] _additionalProperties;
  private CurrencyMatrix _currencyMatrix;

  protected AbstractCurrencyMatrixSourcingFunction(final String currencyMatrixName) {
    _currencyMatrixName = currencyMatrixName;
    _additionalProperties = null;
  }

  protected AbstractCurrencyMatrixSourcingFunction(final String[] params) {
    _currencyMatrixName = params[0];
    _additionalProperties = new String[params.length - 1];
    System.arraycopy(params, 1, _additionalProperties, 0, _additionalProperties.length);
  }

  @Override
  protected ValueProperties.Builder createValueProperties() {
    final ValueProperties.Builder properties = super.createValueProperties();
    properties.with(CURRENCY_MATRIX_NAME_PROPERTY, _currencyMatrixName);
    if (_additionalProperties != null) {
      for (int i = 0; i < _additionalProperties.length; i += 2) {
        properties.with(_additionalProperties[i], _additionalProperties[i + 1]);
      }
    }
    return properties;
  }

  protected CurrencyMatrix getCurrencyMatrix() {
    return _currencyMatrix;
  }

  protected void setCurrencyMatrix(final CurrencyMatrix currencyMatrix) {
    _currencyMatrix = currencyMatrix;
  }

  protected String getCurrencyMatrixName() {
    return _currencyMatrixName;
  }

  @Override
  public void init(final FunctionCompilationContext context) {
    // TODO: [PLAT-2286] This is flawed. The matrix sourcing function should use the resolved matrix as its target so that changes to it will cause
    // re-evaluation. The rate sourcing function should request the value it needs from the sourcing function using constraints to specify the currency
    // pair. E.g. { ticker(s) } -> CurrencyMatrixSourcingFunction(CurrencyMatrix~DEFAULT) -> { Rate(CurrencyMatrix~DEFAULT, Source=USD, Target=GBP) }
    //            { Rate(CurrencyMatrix~DEFAULT, Source=USD, Target=GBP) } -> CurrencyRateSourcingFunction(CurrencyPair~USD_GBP) -> { Rate(CurrencyPair~USD_GBP) }
    // There is a single CurrencyMatrixSourcingFunction in the function repository, there are multiple CurrencyRateSourcingFunctions that correspond
    // to injecting the required matrix name
    final CurrencyMatrix matrix = OpenGammaCompilationContext.getCurrencyMatrixSource(context).getCurrencyMatrix(getCurrencyMatrixName(), VersionCorrection.LATEST);
    setCurrencyMatrix(matrix);
    if (matrix != null) {
      if (matrix.getUniqueId() != null) {
        context.getFunctionReinitializer().reinitializeFunction(this, matrix.getUniqueId().getObjectId());
      }
    }
  }

  @Override
  public ComputationTargetType getTargetType() {
    return CurrencyPair.TYPE;
  }

  @Override
  public boolean canApplyTo(final FunctionCompilationContext context, final ComputationTarget target) {
    // TODO: Don't need this once rewritten to source the matrix correctly
    return (getCurrencyMatrix() != null);
  }

  protected static Object createCrossRate(final Object r1, final Object r2) {
    if (r1 instanceof Double) {
      if (r2 instanceof Double) {
        return (Double) r1 * (Double) r2;
      } else if (r2 instanceof DoubleTimeSeries) {
        return ((DoubleTimeSeries<?>) r2).multiply((Double) r1);
      } else {
        throw new IllegalArgumentException();
      }
    } else if (r1 instanceof DoubleTimeSeries) {
      if (r2 instanceof Double) {
        return ((DoubleTimeSeries<?>) r1).multiply((Double) r2);
      } else if (r2 instanceof DoubleTimeSeries) {
        return ((DoubleTimeSeries<?>) r1).multiply((DoubleTimeSeries<?>) r2);
      } else {
        throw new IllegalArgumentException();
      }
    } else {
      throw new IllegalArgumentException();
    }
  }

  public int getPriority() {
    if (_currencyMatrixName.contains(CurrencyMatrixConfigPopulator.SYNTHETIC_LIVE_DATA)) {
      return -1;
    }
    return 0;
  }

}
