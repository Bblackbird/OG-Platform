/**
 * Copyright (C) 2013 - present by OpenGamma Inc. and the OpenGamma group of companies
 *
 * Please see distribution for license.
 */
package com.opengamma.financial.currency;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Set;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.opengamma.engine.ComputationTarget;
import com.opengamma.engine.ComputationTargetSpecification;
import com.opengamma.engine.function.AbstractFunction;
import com.opengamma.engine.function.FunctionCompilationContext;
import com.opengamma.engine.function.FunctionExecutionContext;
import com.opengamma.engine.function.FunctionInputs;
import com.opengamma.engine.target.ComputationTargetRequirement;
import com.opengamma.engine.target.ComputationTargetType;
import com.opengamma.engine.value.ComputedValue;
import com.opengamma.engine.value.ValueProperties;
import com.opengamma.engine.value.ValueRequirement;
import com.opengamma.engine.value.ValueRequirementNames;
import com.opengamma.engine.value.ValueSpecification;
import com.opengamma.id.ExternalId;
import com.opengamma.id.ExternalIdBundle;

/**
 * Rewrites a requirement to satisfy the currency requirements generated by {@link CurrencyConversionFunction} into one that will query a {@link CurrencyMatrix}.
 */
public class CurrencyMatrixLookupFunction extends AbstractFunction.NonCompiledInvoker {

  /**
   * Property name when applied to a {@link CurrencyPair} target to allow the matrix to be selected.
   */
  protected static final String CURRENCY_MATRIX_NAME_PROPERTY = "CurrencyMatrix";

  private final String _defaultCurrencyMatrixName;
  private final String[] _additionalProperties;

  public CurrencyMatrixLookupFunction(final String defaultCurrencyMatrixName) {
    _defaultCurrencyMatrixName = defaultCurrencyMatrixName;
    _additionalProperties = null;
  }

  public CurrencyMatrixLookupFunction(final String[] params) {
    _defaultCurrencyMatrixName = params[0];
    _additionalProperties = new String[params.length - 1];
    System.arraycopy(params, 1, _additionalProperties, 0, _additionalProperties.length);
  }

  @Override
  protected ValueProperties.Builder createValueProperties() {
    final ValueProperties.Builder properties = super.createValueProperties();
    if (_additionalProperties != null) {
      for (int i = 0; i < _additionalProperties.length; i += 2) {
        properties.with(_additionalProperties[i], _additionalProperties[i + 1]);
      }
    }
    return properties;
  }

  protected String getDefaultCurrencyMatrixName() {
    return _defaultCurrencyMatrixName;
  }

  @Override
  public ComputationTargetType getTargetType() {
    return CurrencyPair.TYPE;
  }

  @Override
  public Set<ValueSpecification> getResults(final FunctionCompilationContext context, final ComputationTarget target) {
    final ComputationTargetSpecification targetSpec = target.toSpecification();
    final ValueProperties properties = createValueProperties().withAny(CURRENCY_MATRIX_NAME_PROPERTY).get();
    return ImmutableSet.of(new ValueSpecification(ValueRequirementNames.SPOT_RATE, targetSpec, properties), new ValueSpecification(ValueRequirementNames.HISTORICAL_FX_TIME_SERIES, targetSpec,
        properties));
  }

  @Override
  public Set<ValueRequirement> getRequirements(final FunctionCompilationContext context, final ComputationTarget target, final ValueRequirement desiredValue) {
    final CurrencyPair currencies = (CurrencyPair) target.getValue();
    Set<String> matrixNames = desiredValue.getConstraints().getValues(CURRENCY_MATRIX_NAME_PROPERTY);
    final ExternalIdBundle matrixIdentifiers;
    if ((matrixNames != null) && !matrixNames.isEmpty()) {
      if (matrixNames.size() == 1) {
        matrixIdentifiers = ExternalId.of(CurrencyMatrixResolver.IDENTIFIER_SCHEME, matrixNames.iterator().next()).toBundle();
      } else {
        final Collection<ExternalId> identifiers = new ArrayList<ExternalId>(matrixNames.size());
        for (String matrixName : matrixNames) {
          identifiers.add(ExternalId.of(CurrencyMatrixResolver.IDENTIFIER_SCHEME, matrixName));
        }
        matrixIdentifiers = ExternalIdBundle.of(identifiers);
      }
    } else {
      matrixIdentifiers = ExternalId.of(CurrencyMatrixResolver.IDENTIFIER_SCHEME, getDefaultCurrencyMatrixName()).toBundle();
    }
    return Collections.singleton(new ValueRequirement(desiredValue.getValueName(), new ComputationTargetRequirement(CurrencyMatrixResolver.TYPE, matrixIdentifiers), ValueProperties
        .with(AbstractCurrencyMatrixSourcingFunction.SOURCE_CURRENCY_PROPERTY, currencies.getCounter().getCode())
        .with(AbstractCurrencyMatrixSourcingFunction.TARGET_CURRENCY_PROPERTY, currencies.getBase().getCode()).get()));
  }

  @Override
  public Set<ValueSpecification> getResults(final FunctionCompilationContext context, final ComputationTarget target, final Map<ValueSpecification, ValueRequirement> inputs) {
    final Set<ValueSpecification> results = Sets.newHashSetWithExpectedSize(inputs.size());
    for (Map.Entry<ValueSpecification, ValueRequirement> inputEntry : inputs.entrySet()) {
      ValueProperties.Builder properties = createValueProperties();
      properties.with(CURRENCY_MATRIX_NAME_PROPERTY, inputEntry.getValue().getTargetReference().getRequirement().getIdentifiers().getValue(CurrencyMatrixResolver.IDENTIFIER_SCHEME));
      results.add(new ValueSpecification(inputEntry.getKey().getValueName(), target.toSpecification(), properties.get()));
    }
    return results;
  }

  @Override
  public Set<ComputedValue> execute(final FunctionExecutionContext executionContext, final FunctionInputs inputs, final ComputationTarget target, final Set<ValueRequirement> desiredValues) {
    final ComputedValue input = inputs.getAllValues().iterator().next();
    final ValueRequirement desiredValue = desiredValues.iterator().next();
    return Collections.singleton(new ComputedValue(new ValueSpecification(desiredValue.getValueName(), target.toSpecification(), desiredValue.getConstraints()), input.getValue()));
  }

  public int getPriority() {
    if (getDefaultCurrencyMatrixName().contains(CurrencyMatrixConfigPopulator.SYNTHETIC_LIVE_DATA)) {
      return -1;
    }
    return 0;
  }

}
